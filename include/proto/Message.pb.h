// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Message.proto

#ifndef PROTOBUF_Message_2eproto__INCLUDED
#define PROTOBUF_Message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Message_2eproto();
void protobuf_AssignDesc_Message_2eproto();
void protobuf_ShutdownFile_Message_2eproto();

class TestRequestAB;
class TestResponseAB;
class TestRequestAC;
class TestResponseAC;
class TestRequestBA;
class TestResponseBA;
class TestRequestBC;
class TestResponseBC;
class TestRequestCA;
class TestResponseCA;
class TestRequestCB;
class TestResponseCB;

// ===================================================================

class TestRequestAB : public ::google::protobuf::MessageLite {
 public:
  TestRequestAB();
  virtual ~TestRequestAB();

  TestRequestAB(const TestRequestAB& from);

  inline TestRequestAB& operator=(const TestRequestAB& from) {
    CopyFrom(from);
    return *this;
  }

  static const TestRequestAB& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TestRequestAB* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TestRequestAB* other);

  // implements Message ----------------------------------------------

  TestRequestAB* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TestRequestAB& from);
  void MergeFrom(const TestRequestAB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string debug_info = 2;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 2;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  inline void set_allocated_debug_info(::std::string* debug_info);

  // @@protoc_insertion_point(class_scope:TestRequestAB)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_debug_info();
  inline void clear_has_debug_info();

  ::google::protobuf::uint64 id_;
  ::std::string* debug_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static TestRequestAB* default_instance_;
};
// -------------------------------------------------------------------

class TestResponseAB : public ::google::protobuf::MessageLite {
 public:
  TestResponseAB();
  virtual ~TestResponseAB();

  TestResponseAB(const TestResponseAB& from);

  inline TestResponseAB& operator=(const TestResponseAB& from) {
    CopyFrom(from);
    return *this;
  }

  static const TestResponseAB& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TestResponseAB* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TestResponseAB* other);

  // implements Message ----------------------------------------------

  TestResponseAB* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TestResponseAB& from);
  void MergeFrom(const TestResponseAB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string debug_info = 2;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 2;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  inline void set_allocated_debug_info(::std::string* debug_info);

  // @@protoc_insertion_point(class_scope:TestResponseAB)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_debug_info();
  inline void clear_has_debug_info();

  ::google::protobuf::uint64 id_;
  ::std::string* debug_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static TestResponseAB* default_instance_;
};
// -------------------------------------------------------------------

class TestRequestAC : public ::google::protobuf::MessageLite {
 public:
  TestRequestAC();
  virtual ~TestRequestAC();

  TestRequestAC(const TestRequestAC& from);

  inline TestRequestAC& operator=(const TestRequestAC& from) {
    CopyFrom(from);
    return *this;
  }

  static const TestRequestAC& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TestRequestAC* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TestRequestAC* other);

  // implements Message ----------------------------------------------

  TestRequestAC* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TestRequestAC& from);
  void MergeFrom(const TestRequestAC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string debug_info = 2;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 2;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  inline void set_allocated_debug_info(::std::string* debug_info);

  // @@protoc_insertion_point(class_scope:TestRequestAC)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_debug_info();
  inline void clear_has_debug_info();

  ::google::protobuf::uint64 id_;
  ::std::string* debug_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static TestRequestAC* default_instance_;
};
// -------------------------------------------------------------------

class TestResponseAC : public ::google::protobuf::MessageLite {
 public:
  TestResponseAC();
  virtual ~TestResponseAC();

  TestResponseAC(const TestResponseAC& from);

  inline TestResponseAC& operator=(const TestResponseAC& from) {
    CopyFrom(from);
    return *this;
  }

  static const TestResponseAC& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TestResponseAC* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TestResponseAC* other);

  // implements Message ----------------------------------------------

  TestResponseAC* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TestResponseAC& from);
  void MergeFrom(const TestResponseAC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string debug_info = 2;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 2;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  inline void set_allocated_debug_info(::std::string* debug_info);

  // @@protoc_insertion_point(class_scope:TestResponseAC)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_debug_info();
  inline void clear_has_debug_info();

  ::google::protobuf::uint64 id_;
  ::std::string* debug_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static TestResponseAC* default_instance_;
};
// -------------------------------------------------------------------

class TestRequestBA : public ::google::protobuf::MessageLite {
 public:
  TestRequestBA();
  virtual ~TestRequestBA();

  TestRequestBA(const TestRequestBA& from);

  inline TestRequestBA& operator=(const TestRequestBA& from) {
    CopyFrom(from);
    return *this;
  }

  static const TestRequestBA& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TestRequestBA* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TestRequestBA* other);

  // implements Message ----------------------------------------------

  TestRequestBA* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TestRequestBA& from);
  void MergeFrom(const TestRequestBA& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string debug_info = 2;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 2;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  inline void set_allocated_debug_info(::std::string* debug_info);

  // @@protoc_insertion_point(class_scope:TestRequestBA)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_debug_info();
  inline void clear_has_debug_info();

  ::google::protobuf::uint64 id_;
  ::std::string* debug_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static TestRequestBA* default_instance_;
};
// -------------------------------------------------------------------

class TestResponseBA : public ::google::protobuf::MessageLite {
 public:
  TestResponseBA();
  virtual ~TestResponseBA();

  TestResponseBA(const TestResponseBA& from);

  inline TestResponseBA& operator=(const TestResponseBA& from) {
    CopyFrom(from);
    return *this;
  }

  static const TestResponseBA& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TestResponseBA* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TestResponseBA* other);

  // implements Message ----------------------------------------------

  TestResponseBA* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TestResponseBA& from);
  void MergeFrom(const TestResponseBA& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string debug_info = 2;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 2;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  inline void set_allocated_debug_info(::std::string* debug_info);

  // @@protoc_insertion_point(class_scope:TestResponseBA)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_debug_info();
  inline void clear_has_debug_info();

  ::google::protobuf::uint64 id_;
  ::std::string* debug_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static TestResponseBA* default_instance_;
};
// -------------------------------------------------------------------

class TestRequestBC : public ::google::protobuf::MessageLite {
 public:
  TestRequestBC();
  virtual ~TestRequestBC();

  TestRequestBC(const TestRequestBC& from);

  inline TestRequestBC& operator=(const TestRequestBC& from) {
    CopyFrom(from);
    return *this;
  }

  static const TestRequestBC& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TestRequestBC* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TestRequestBC* other);

  // implements Message ----------------------------------------------

  TestRequestBC* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TestRequestBC& from);
  void MergeFrom(const TestRequestBC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string debug_info = 2;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 2;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  inline void set_allocated_debug_info(::std::string* debug_info);

  // @@protoc_insertion_point(class_scope:TestRequestBC)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_debug_info();
  inline void clear_has_debug_info();

  ::google::protobuf::uint64 id_;
  ::std::string* debug_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static TestRequestBC* default_instance_;
};
// -------------------------------------------------------------------

class TestResponseBC : public ::google::protobuf::MessageLite {
 public:
  TestResponseBC();
  virtual ~TestResponseBC();

  TestResponseBC(const TestResponseBC& from);

  inline TestResponseBC& operator=(const TestResponseBC& from) {
    CopyFrom(from);
    return *this;
  }

  static const TestResponseBC& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TestResponseBC* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TestResponseBC* other);

  // implements Message ----------------------------------------------

  TestResponseBC* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TestResponseBC& from);
  void MergeFrom(const TestResponseBC& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string debug_info = 2;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 2;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  inline void set_allocated_debug_info(::std::string* debug_info);

  // @@protoc_insertion_point(class_scope:TestResponseBC)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_debug_info();
  inline void clear_has_debug_info();

  ::google::protobuf::uint64 id_;
  ::std::string* debug_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static TestResponseBC* default_instance_;
};
// -------------------------------------------------------------------

class TestRequestCA : public ::google::protobuf::MessageLite {
 public:
  TestRequestCA();
  virtual ~TestRequestCA();

  TestRequestCA(const TestRequestCA& from);

  inline TestRequestCA& operator=(const TestRequestCA& from) {
    CopyFrom(from);
    return *this;
  }

  static const TestRequestCA& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TestRequestCA* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TestRequestCA* other);

  // implements Message ----------------------------------------------

  TestRequestCA* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TestRequestCA& from);
  void MergeFrom(const TestRequestCA& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string debug_info = 2;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 2;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  inline void set_allocated_debug_info(::std::string* debug_info);

  // @@protoc_insertion_point(class_scope:TestRequestCA)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_debug_info();
  inline void clear_has_debug_info();

  ::google::protobuf::uint64 id_;
  ::std::string* debug_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static TestRequestCA* default_instance_;
};
// -------------------------------------------------------------------

class TestResponseCA : public ::google::protobuf::MessageLite {
 public:
  TestResponseCA();
  virtual ~TestResponseCA();

  TestResponseCA(const TestResponseCA& from);

  inline TestResponseCA& operator=(const TestResponseCA& from) {
    CopyFrom(from);
    return *this;
  }

  static const TestResponseCA& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TestResponseCA* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TestResponseCA* other);

  // implements Message ----------------------------------------------

  TestResponseCA* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TestResponseCA& from);
  void MergeFrom(const TestResponseCA& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string debug_info = 2;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 2;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  inline void set_allocated_debug_info(::std::string* debug_info);

  // @@protoc_insertion_point(class_scope:TestResponseCA)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_debug_info();
  inline void clear_has_debug_info();

  ::google::protobuf::uint64 id_;
  ::std::string* debug_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static TestResponseCA* default_instance_;
};
// -------------------------------------------------------------------

class TestRequestCB : public ::google::protobuf::MessageLite {
 public:
  TestRequestCB();
  virtual ~TestRequestCB();

  TestRequestCB(const TestRequestCB& from);

  inline TestRequestCB& operator=(const TestRequestCB& from) {
    CopyFrom(from);
    return *this;
  }

  static const TestRequestCB& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TestRequestCB* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TestRequestCB* other);

  // implements Message ----------------------------------------------

  TestRequestCB* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TestRequestCB& from);
  void MergeFrom(const TestRequestCB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string debug_info = 2;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 2;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  inline void set_allocated_debug_info(::std::string* debug_info);

  // @@protoc_insertion_point(class_scope:TestRequestCB)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_debug_info();
  inline void clear_has_debug_info();

  ::google::protobuf::uint64 id_;
  ::std::string* debug_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static TestRequestCB* default_instance_;
};
// -------------------------------------------------------------------

class TestResponseCB : public ::google::protobuf::MessageLite {
 public:
  TestResponseCB();
  virtual ~TestResponseCB();

  TestResponseCB(const TestResponseCB& from);

  inline TestResponseCB& operator=(const TestResponseCB& from) {
    CopyFrom(from);
    return *this;
  }

  static const TestResponseCB& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TestResponseCB* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TestResponseCB* other);

  // implements Message ----------------------------------------------

  TestResponseCB* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TestResponseCB& from);
  void MergeFrom(const TestResponseCB& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string debug_info = 2;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 2;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  inline void set_allocated_debug_info(::std::string* debug_info);

  // @@protoc_insertion_point(class_scope:TestResponseCB)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_debug_info();
  inline void clear_has_debug_info();

  ::google::protobuf::uint64 id_;
  ::std::string* debug_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Message_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Message_2eproto();
  #endif
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();

  void InitAsDefaultInstance();
  static TestResponseCB* default_instance_;
};
// ===================================================================


// ===================================================================

// TestRequestAB

// optional uint64 ID = 1;
inline bool TestRequestAB::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestRequestAB::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestRequestAB::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestRequestAB::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 TestRequestAB::id() const {
  return id_;
}
inline void TestRequestAB::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string debug_info = 2;
inline bool TestRequestAB::has_debug_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestRequestAB::set_has_debug_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestRequestAB::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestRequestAB::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& TestRequestAB::debug_info() const {
  return *debug_info_;
}
inline void TestRequestAB::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestRequestAB::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestRequestAB::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TestRequestAB::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* TestRequestAB::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TestRequestAB::set_allocated_debug_info(::std::string* debug_info) {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    delete debug_info_;
  }
  if (debug_info) {
    set_has_debug_info();
    debug_info_ = debug_info;
  } else {
    clear_has_debug_info();
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TestResponseAB

// optional uint64 ID = 1;
inline bool TestResponseAB::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestResponseAB::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestResponseAB::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestResponseAB::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 TestResponseAB::id() const {
  return id_;
}
inline void TestResponseAB::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string debug_info = 2;
inline bool TestResponseAB::has_debug_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestResponseAB::set_has_debug_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestResponseAB::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestResponseAB::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& TestResponseAB::debug_info() const {
  return *debug_info_;
}
inline void TestResponseAB::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestResponseAB::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestResponseAB::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TestResponseAB::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* TestResponseAB::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TestResponseAB::set_allocated_debug_info(::std::string* debug_info) {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    delete debug_info_;
  }
  if (debug_info) {
    set_has_debug_info();
    debug_info_ = debug_info;
  } else {
    clear_has_debug_info();
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TestRequestAC

// optional uint64 ID = 1;
inline bool TestRequestAC::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestRequestAC::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestRequestAC::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestRequestAC::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 TestRequestAC::id() const {
  return id_;
}
inline void TestRequestAC::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string debug_info = 2;
inline bool TestRequestAC::has_debug_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestRequestAC::set_has_debug_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestRequestAC::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestRequestAC::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& TestRequestAC::debug_info() const {
  return *debug_info_;
}
inline void TestRequestAC::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestRequestAC::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestRequestAC::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TestRequestAC::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* TestRequestAC::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TestRequestAC::set_allocated_debug_info(::std::string* debug_info) {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    delete debug_info_;
  }
  if (debug_info) {
    set_has_debug_info();
    debug_info_ = debug_info;
  } else {
    clear_has_debug_info();
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TestResponseAC

// optional uint64 ID = 1;
inline bool TestResponseAC::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestResponseAC::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestResponseAC::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestResponseAC::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 TestResponseAC::id() const {
  return id_;
}
inline void TestResponseAC::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string debug_info = 2;
inline bool TestResponseAC::has_debug_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestResponseAC::set_has_debug_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestResponseAC::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestResponseAC::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& TestResponseAC::debug_info() const {
  return *debug_info_;
}
inline void TestResponseAC::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestResponseAC::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestResponseAC::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TestResponseAC::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* TestResponseAC::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TestResponseAC::set_allocated_debug_info(::std::string* debug_info) {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    delete debug_info_;
  }
  if (debug_info) {
    set_has_debug_info();
    debug_info_ = debug_info;
  } else {
    clear_has_debug_info();
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TestRequestBA

// optional uint64 ID = 1;
inline bool TestRequestBA::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestRequestBA::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestRequestBA::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestRequestBA::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 TestRequestBA::id() const {
  return id_;
}
inline void TestRequestBA::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string debug_info = 2;
inline bool TestRequestBA::has_debug_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestRequestBA::set_has_debug_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestRequestBA::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestRequestBA::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& TestRequestBA::debug_info() const {
  return *debug_info_;
}
inline void TestRequestBA::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestRequestBA::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestRequestBA::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TestRequestBA::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* TestRequestBA::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TestRequestBA::set_allocated_debug_info(::std::string* debug_info) {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    delete debug_info_;
  }
  if (debug_info) {
    set_has_debug_info();
    debug_info_ = debug_info;
  } else {
    clear_has_debug_info();
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TestResponseBA

// optional uint64 ID = 1;
inline bool TestResponseBA::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestResponseBA::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestResponseBA::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestResponseBA::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 TestResponseBA::id() const {
  return id_;
}
inline void TestResponseBA::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string debug_info = 2;
inline bool TestResponseBA::has_debug_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestResponseBA::set_has_debug_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestResponseBA::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestResponseBA::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& TestResponseBA::debug_info() const {
  return *debug_info_;
}
inline void TestResponseBA::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestResponseBA::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestResponseBA::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TestResponseBA::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* TestResponseBA::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TestResponseBA::set_allocated_debug_info(::std::string* debug_info) {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    delete debug_info_;
  }
  if (debug_info) {
    set_has_debug_info();
    debug_info_ = debug_info;
  } else {
    clear_has_debug_info();
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TestRequestBC

// optional uint64 ID = 1;
inline bool TestRequestBC::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestRequestBC::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestRequestBC::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestRequestBC::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 TestRequestBC::id() const {
  return id_;
}
inline void TestRequestBC::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string debug_info = 2;
inline bool TestRequestBC::has_debug_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestRequestBC::set_has_debug_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestRequestBC::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestRequestBC::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& TestRequestBC::debug_info() const {
  return *debug_info_;
}
inline void TestRequestBC::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestRequestBC::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestRequestBC::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TestRequestBC::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* TestRequestBC::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TestRequestBC::set_allocated_debug_info(::std::string* debug_info) {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    delete debug_info_;
  }
  if (debug_info) {
    set_has_debug_info();
    debug_info_ = debug_info;
  } else {
    clear_has_debug_info();
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TestResponseBC

// optional uint64 ID = 1;
inline bool TestResponseBC::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestResponseBC::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestResponseBC::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestResponseBC::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 TestResponseBC::id() const {
  return id_;
}
inline void TestResponseBC::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string debug_info = 2;
inline bool TestResponseBC::has_debug_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestResponseBC::set_has_debug_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestResponseBC::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestResponseBC::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& TestResponseBC::debug_info() const {
  return *debug_info_;
}
inline void TestResponseBC::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestResponseBC::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestResponseBC::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TestResponseBC::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* TestResponseBC::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TestResponseBC::set_allocated_debug_info(::std::string* debug_info) {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    delete debug_info_;
  }
  if (debug_info) {
    set_has_debug_info();
    debug_info_ = debug_info;
  } else {
    clear_has_debug_info();
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TestRequestCA

// optional uint64 ID = 1;
inline bool TestRequestCA::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestRequestCA::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestRequestCA::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestRequestCA::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 TestRequestCA::id() const {
  return id_;
}
inline void TestRequestCA::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string debug_info = 2;
inline bool TestRequestCA::has_debug_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestRequestCA::set_has_debug_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestRequestCA::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestRequestCA::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& TestRequestCA::debug_info() const {
  return *debug_info_;
}
inline void TestRequestCA::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestRequestCA::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestRequestCA::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TestRequestCA::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* TestRequestCA::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TestRequestCA::set_allocated_debug_info(::std::string* debug_info) {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    delete debug_info_;
  }
  if (debug_info) {
    set_has_debug_info();
    debug_info_ = debug_info;
  } else {
    clear_has_debug_info();
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TestResponseCA

// optional uint64 ID = 1;
inline bool TestResponseCA::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestResponseCA::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestResponseCA::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestResponseCA::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 TestResponseCA::id() const {
  return id_;
}
inline void TestResponseCA::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string debug_info = 2;
inline bool TestResponseCA::has_debug_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestResponseCA::set_has_debug_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestResponseCA::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestResponseCA::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& TestResponseCA::debug_info() const {
  return *debug_info_;
}
inline void TestResponseCA::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestResponseCA::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestResponseCA::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TestResponseCA::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* TestResponseCA::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TestResponseCA::set_allocated_debug_info(::std::string* debug_info) {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    delete debug_info_;
  }
  if (debug_info) {
    set_has_debug_info();
    debug_info_ = debug_info;
  } else {
    clear_has_debug_info();
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TestRequestCB

// optional uint64 ID = 1;
inline bool TestRequestCB::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestRequestCB::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestRequestCB::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestRequestCB::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 TestRequestCB::id() const {
  return id_;
}
inline void TestRequestCB::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string debug_info = 2;
inline bool TestRequestCB::has_debug_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestRequestCB::set_has_debug_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestRequestCB::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestRequestCB::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& TestRequestCB::debug_info() const {
  return *debug_info_;
}
inline void TestRequestCB::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestRequestCB::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestRequestCB::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TestRequestCB::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* TestRequestCB::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TestRequestCB::set_allocated_debug_info(::std::string* debug_info) {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    delete debug_info_;
  }
  if (debug_info) {
    set_has_debug_info();
    debug_info_ = debug_info;
  } else {
    clear_has_debug_info();
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TestResponseCB

// optional uint64 ID = 1;
inline bool TestResponseCB::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestResponseCB::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestResponseCB::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestResponseCB::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 TestResponseCB::id() const {
  return id_;
}
inline void TestResponseCB::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string debug_info = 2;
inline bool TestResponseCB::has_debug_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestResponseCB::set_has_debug_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestResponseCB::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestResponseCB::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& TestResponseCB::debug_info() const {
  return *debug_info_;
}
inline void TestResponseCB::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestResponseCB::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void TestResponseCB::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TestResponseCB::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* TestResponseCB::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TestResponseCB::set_allocated_debug_info(::std::string* debug_info) {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    delete debug_info_;
  }
  if (debug_info) {
    set_has_debug_info();
    debug_info_ = debug_info;
  } else {
    clear_has_debug_info();
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Message_2eproto__INCLUDED
